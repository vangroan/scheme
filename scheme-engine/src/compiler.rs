use crate::env::{ConstantId, Env};
use crate::error::{Error, Result};
use crate::expr::{Closure, Expr, Proc};
use crate::handle::Handle;
use crate::opcode::Op;
use crate::symbol::{SymbolId, SymbolTable};
use std::rc::Rc;

/// Compiles the given expression into bytecode.
///
/// The given environment will be used as the environment
/// of the created procedure.
pub fn compile(env: Handle<Env>, expr: &Expr) -> Result<Handle<Closure>> {
    // Create a new procedure to act as the top level execution context.
    let proc = ProcState::new();

    let mut compiler = Compiler {
        env,
        proc,
        proc_stack: Vec::new(),
    };

    compiler.compile_expr(expr)?;

    let (_env, proc) = compiler.take_procedure()?;

    // debug dump the generated bytecode
    // println!("bytecode:");
    // for (index, op) in proc.code.iter().enumerate() {
    //     println!("  {index:>6} : {op:?}");
    // }

    let closure = Closure::new(Rc::new(proc));

    Ok(Handle::new(closure))
}

struct Compiler {
    /// The current procedure being compiled.
    /// TODO: Once the environment stack is figured out, we could change this to a borrow.
    env: Handle<Env>,

    /// The current procedure being compiled.
    proc: ProcState,

    /// Stack of procedure scopes being compiled.
    proc_stack: Vec<ProcState>,
}

impl Compiler {
    fn take_procedure(self) -> Result<(Handle<Env>, Proc)> {
        let Self { env, proc, .. } = self;

        // Convert the procedure state to an immutable procedure definition
        // suitable for the virtual machine.
        let proc = Proc {
            code: proc.code.into_boxed_slice(),
            // The top level procedures never take arguments.
            arity: 0,
            // By storing the procedure in the environment
            // we've created a circular reference.
            env: env.downgrade(),
        };

        Ok((env, proc))
    }

    fn compile_expr(&mut self, expr: &Expr) -> Result<()> {
        println!("compiler::compile_expr({expr:?})");

        match expr {
            // Number literal
            Expr::Number(number) => {
                let constant_id = self.add_constant(expr.clone());
                self.proc.emit_op(Op::PushConstant(constant_id));
            }
            // Boolean literal
            Expr::Bool(boolean) => {
                todo!("boolean literal")
            }
            Expr::Ident(ident) => {
                // Attempt to access a variable by identifier.
                self.compile_access(ident.as_str())?;
            }
            Expr::List(list) => {
                // The default s-expression form is a procedure call.
                self.compile_call(list.as_slice())?;
            }
            _ => todo!("compile_expr: {expr:?}"),
        }

        Ok(())
    }

    /// Compile variable access.
    fn compile_access(&mut self, name: &str) -> Result<Variable> {
        let symbol = self
            .env
            .borrow()
            .resolve_var(name)
            .ok_or_else(|| Error::Reason(format!("unbound variable {name:?}")))?;

        // VM: Load the variable from the environment onto the operand stack.
        self.proc.emit_op(Op::LoadEnvVar(symbol));

        Ok(Variable { symbol })
    }

    fn compile_call(&mut self, list: &[Expr]) -> Result<()> {
        println!("compiler::compile_call({list:?})");

        if list.is_empty() {
            return Err(Error::Reason("ill-formed expression".to_string()));
        }

        match &list[0] {
            Expr::Ident(ident) => {
                let rest = &list[1..];
                println!("rest of arguments: {rest:?}");

                // TODO: Walk scope in reverse to find variable.

                // Lookup procedure using the first atom of the sequence.
                let symbol = self
                    .env
                    .borrow()
                    .resolve_var(ident.as_str())
                    .ok_or_else(|| Error::Reason(format!("unbound variable {ident:?}")))?;
                let value = self.env.borrow().get_var(symbol).cloned().unwrap();
                self.proc.emit_op(Op::LoadEnvVar(symbol));

                // TODO: Variadic procedures take the rest of their arguments as list. We need to store signature information to accomplish this.
                for arg in rest {
                    self.compile_expr(arg)?;
                }

                match value {
                    Expr::Closure(_) => todo!("call closure"),
                    Expr::NativeFunc(_) => self.proc.emit_op(Op::CallNative {
                        arity: rest.len() as u8,
                    }),
                    Expr::Procedure(_) => {
                        // Procedures are not stored in variables, but are rather
                        // wrapped in closures when defined.
                        //
                        // This adds overhead when creating the procedure, but simplifies
                        // the interpreter implementation because the VM only needs to
                        // know how to call closures.
                        panic!("procedures cannot be called directly")
                    }
                    _ => todo!("call type not supported yet"),
                }

                Ok(())
            }
            _ => Err(Error::Reason("operator is not a procedure".to_string())),
        }
    }

    /// Add a constant value to the current environment.
    fn add_constant(&mut self, value: Expr) -> ConstantId {
        match self.proc.constants.iter().position(|el| el == &value) {
            Some(index) => ConstantId::new(index as u16),
            None => {
                let next_index = self.proc.constants.len();
                self.proc.constants.push(value);
                ConstantId::new(next_index as u16)
            }
        }
    }
}

/// Mutable bookkeeping for compiling a procedure.
struct ProcState {
    /// Generated result bytecode.
    code: Vec<Op>,

    constants: Vec<Expr>,
}

impl ProcState {
    fn new() -> Self {
        Self {
            code: Vec::new(),
            constants: Vec::new(),
        }
    }

    fn emit_op(&mut self, op: Op) {
        self.code.push(op)
    }
}

#[derive(Debug)]
struct Variable {
    symbol: SymbolId,
}
