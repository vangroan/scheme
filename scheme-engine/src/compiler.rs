use crate::env::{ConstantId, Env};
use crate::error::{Error, Result};
use crate::expr::{Closure, Expr, Proc};
use crate::handle::Handle;
use crate::opcode::Op;
use crate::symbol::{SymbolId, SymbolTable};
use std::rc::Rc;

/// Compiles the given expression into bytecode.
///
/// The given environment will be used as the environment
/// of the created procedure.
pub fn compile(env: Handle<Env>, expr: &Expr) -> Result<Handle<Closure>> {
    // Create a new procedure to act as the top level execution context.
    let proc = ProcState::new();

    let mut compiler = Compiler {
        env,
        proc,
        proc_stack: Vec::new(),
    };

    compiler.compile_expr(expr)?;
    compiler.compile_end()?;

    let (_env, proc) = compiler.take_procedure()?;

    // debug dump the generated bytecode
    // println!("bytecode:");
    // for (index, op) in proc.code.iter().enumerate() {
    //     println!("  {index:>6} : {op:?}");
    // }

    let closure = Closure::new(Rc::new(proc));

    Ok(Handle::new(closure))
}

struct Compiler {
    /// The current procedure being compiled.
    /// TODO: Once the environment stack is figured out, we could change this to a borrow.
    env: Handle<Env>,

    /// The current procedure being compiled.
    proc: ProcState,

    /// Stack of procedure scopes being compiled.
    proc_stack: Vec<ProcState>,
}

impl Compiler {
    fn take_procedure(self) -> Result<(Handle<Env>, Proc)> {
        let Self { env, proc, .. } = self;

        // Convert the procedure state to an immutable procedure definition
        // suitable for the virtual machine.
        let proc = Proc {
            code: proc.code.into_boxed_slice(),
            // The top level procedures never take arguments.
            arity: 0,
            constants: proc.constants.into_boxed_slice(),
            // By storing the procedure in the environment
            // we've created a circular reference.
            env: env.downgrade(),
        };

        Ok((env, proc))
    }

    fn compile_expr(&mut self, expr: &Expr) -> Result<()> {
        println!("compiler::compile_expr({expr:?})");

        match expr {
            // Nil literal
            Expr::Nil => {
                self.proc.emit_op(Op::PushNil);
            }
            // Number literal
            Expr::Number(number) => {
                let constant_id = self.add_constant(expr.clone());
                self.proc.emit_op(Op::PushConstant(constant_id));
            }
            // Boolean literal
            Expr::Bool(boolean) => {
                let op = if *boolean {
                    Op::PushTrue
                } else {
                    Op::PushFalse
                };
                self.proc.emit_op(op);
            }
            Expr::Ident(ident) => {
                // Attempt to access a variable by identifier.
                self.compile_access(ident.as_str())?;
            }
            Expr::List(list) => {
                // The default s-expression form is a procedure call.
                self.compile_call(list.as_slice())?;
            }
            _ => todo!("compile_expr: {expr:?}"),
        }

        Ok(())
    }

    fn compile_end(&mut self) -> Result<()> {
        self.proc.emit_op(Op::End);
        Ok(())
    }

    /// Compile variable access.
    fn compile_access(&mut self, name: &str) -> Result<Variable> {
        let symbol = self
            .env
            .borrow()
            .resolve_var(name)
            .ok_or_else(|| Error::Reason(format!("unbound variable {name:?}")))?;

        // VM: Load the variable from the environment onto the operand stack.
        self.proc.emit_op(Op::LoadEnvVar(symbol));

        Ok(Variable { symbol })
    }

    fn compile_call(&mut self, list: &[Expr]) -> Result<()> {
        println!("compiler::compile_call({list:?})");

        if list.is_empty() {
            return Err(Error::Reason("ill-formed expression".to_string()));
        }

        match &list[0] {
            Expr::Ident(ident) => {
                let rest = &list[1..];
                println!("rest of arguments: {rest:?}");

                // Attempt to compile the call as a special form.
                if self.compile_fundamental(ident.as_str(), rest)? {
                    return Ok(());
                }

                // TODO: Walk scope in reverse to find variable.

                // Lookup procedure using the first atom of the sequence.
                let symbol = self
                    .env
                    .borrow()
                    .resolve_var(ident.as_str())
                    .ok_or_else(|| Error::Reason(format!("unbound variable {ident:?}")))?;
                let value = self.env.borrow().get_var(symbol).cloned().unwrap();
                self.proc.emit_op(Op::LoadEnvVar(symbol));

                // TODO: Variadic procedures take the rest of their arguments as list. We need to store signature information to accomplish this.
                for arg in rest {
                    self.compile_expr(arg)?;
                }

                match value {
                    Expr::Closure(_) => todo!("call closure"),
                    Expr::NativeFunc(_) => self.proc.emit_op(Op::CallNative {
                        arity: rest.len() as u8,
                    }),
                    Expr::Procedure(_) => {
                        // Procedures are not stored in variables, but are rather
                        // wrapped in closures when defined.
                        //
                        // This adds overhead when creating the procedure, but simplifies
                        // the interpreter implementation because the VM only needs to
                        // know how to call closures.
                        panic!("procedures cannot be called directly")
                    }
                    _ => todo!("call type not supported yet"),
                }

                Ok(())
            }
            _ => Err(Error::Reason("operator is not a procedure".to_string())),
        }
    }

    /// Attempt to compile the identifier as a fundamental form.
    ///
    /// These are special forms with unusual evaluation rules,
    /// and can be expressed by inlined bytecode.
    ///
    /// # Return
    ///
    /// Returns `true` if the identifier is considered a fundamental form.
    /// Returns `false` if the form cannot be identified, and no bytecode will have been emitted.
    fn compile_fundamental(&mut self, ident: &str, rest: &[Expr]) -> Result<bool> {
        // TODO: When the identifiers themselves are evaluated then a special error must be raised.
        // > define
        // error: fundamental name cannot be used as a variable.
        match ident {
            "define" => {
                self.compile_define_form(rest)?;
                Ok(true)
            }
            "lambda" => {
                todo!("lambda special form")
            }
            _ => Ok(false),
        }
    }

    /// Compile the `define` form.
    ///
    /// A fundamental form that defines a variable in the current environment.
    ///
    /// Defines can appear in two places, at the top level of a program
    /// where they are called **top-level definitions** or at the beginning
    /// of a body where they are called **internal definitions**. It is an
    /// error to place a define anywhere else.
    ///
    /// Defines also have a second form that also defines a procedure.
    ///
    /// # Return
    ///
    /// Returns the [`SymbolId`] of the defined variable.
    fn compile_define_form(&mut self, rest: &[Expr]) -> Result<SymbolId> {
        // TODO: `define` expression may only appear in specific places.
        match rest
            .get(0)
            .ok_or_else(|| Error::Reason("identifier expected".to_string()))?
        {
            Expr::Ident(var_name) => {
                // Variables can be redefined
                let symbol = self.env.borrow_mut().intern_var(var_name);

                // Define body is an expression, but may be omitted.
                // TODO: Do we need an undefined, unspecified or void value?
                let body = rest.get(1).unwrap_or(&Expr::Nil);

                // This expression leaves a value on the stack.
                self.compile_expr(body)?;

                self.proc.emit_op(Op::StoreEnvVar(symbol));
                self.proc.emit_op(Op::Pop);
                Ok(symbol)
            }
            Expr::List(_formals) => {
                todo!("procedure definition")
            }
            _ => Err(Error::Reason("ill-formed special form".to_string())),
        }
    }

    /// Add a constant value to the current environment.
    fn add_constant(&mut self, value: Expr) -> ConstantId {
        match self.proc.constants.iter().position(|el| el == &value) {
            Some(index) => ConstantId::new(index as u16),
            None => {
                let next_index = self.proc.constants.len();
                self.proc.constants.push(value);
                ConstantId::new(next_index as u16)
            }
        }
    }
}

/// Mutable bookkeeping for compiling a procedure.
struct ProcState {
    /// Generated result bytecode.
    code: Vec<Op>,

    constants: Vec<Expr>,
}

impl ProcState {
    fn new() -> Self {
        Self {
            code: Vec::new(),
            constants: Vec::new(),
        }
    }

    fn emit_op(&mut self, op: Op) {
        self.code.push(op)
    }
}

#[derive(Debug)]
struct Variable {
    symbol: SymbolId,
}
