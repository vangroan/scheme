use std::mem;
use std::rc::Rc;

use smol_str::SmolStr;

use crate::declare_id;
use crate::env::{ConstantId, Env, LocalId, UpValueId};
use crate::error::{Error, Result};
use crate::expr::{Closure, Expr, Keyword, Proc, Signature};
use crate::handle::Handle;
use crate::limits::*;
use crate::opcode::{JumpAddr, Op, UpValueOrigin};
use crate::symbol::SymbolId;

/// Compiles the given top-level expression into bytecode.
///
/// The given environment will be used as the environment
/// of the created procedure.
pub fn compile(env: Handle<Env>, expr: &Expr) -> Result<Handle<Closure>> {
    // Create a new procedure to act as the top level execution context.
    let proc = ProcState::new();

    let mut compiler = Compiler {
        env,
        proc,
        proc_stack: Vec::new(),
        // Compilation starts at the top level of a program.
        context: Context::TopLevel,
        depth: 0,
        stack_offset: 0,
        stack_offsets: Vec::new(),
    };

    compiler.compile_expr(expr)?;
    compiler.compile_end()?;

    let (_env, proc) = compiler.take_procedure()?;

    // debug dump the generated bytecode
    println!("bytecode:");
    for (index, op) in proc.code.iter().enumerate() {
        println!("  {index:>6} : {op:?}");
    }

    let closure = Closure::new(Rc::new(proc));

    Ok(Handle::new(closure))
}

macro_rules! error_unbound_variable {
    ($name:expr) => {
        Error::Reason(format!("unbound variable {:?}", $name))
    };
}

macro_rules! error_ill_special_form {
    ($name:expr) => {
        Error::Reason(format!("ill-formed special form {:?}", $name))
    };
}

// TODO: Establish rules on whether the compiler may or may not mutate the given environment.
struct Compiler {
    /// The current procedure being compiled.
    /// TODO: Once the environment stack is figured out, we could change this to a borrow.
    env: Handle<Env>,

    /// The current procedure being compiled.
    proc: ProcState,

    /// Stack of procedure scopes being compiled.
    proc_stack: Vec<ProcState>,

    /// Keeps track of the scope context as the compiler drills down into expressions.
    ///
    /// This is for the unusual semantics required by special forms.
    ///
    /// See [`Compiler::compile_special_form`] for special forms.
    context: Context,

    /// The current scope depth.
    ///
    /// Used to keep track of which lexical scope local variables are declared in.
    depth: usize,

    /// The position (index) in the [`locals`] stack where the current scope's
    /// local variables start.
    ///
    /// Any [`LocalId`] declared within the current scope will be relative to
    /// this position.
    stack_offset: usize,
    stack_offsets: Vec<usize>,
}

impl Compiler {
    /// Consume the compiler and take the last procedure as the top-level program.
    fn take_procedure(self) -> Result<(Handle<Env>, Proc)> {
        let Self { env, proc, .. } = self;

        // Convert the procedure state to an immutable procedure definition
        // suitable for the virtual machine.
        let proc = Proc {
            code: proc.code.into_boxed_slice(),
            // Top-level procedures never take arguments.
            sig: Signature::empty(),
            constants: proc.constants.into_boxed_slice(),
            // Top-level procedure doesn't have local variables.
            // Rather, variables are declared as global in the paired environment.
            local_count: 0,
            // Top-level procedure doesn't close over anything, because
            // there are no outer scopes.
            up_value_count: 0,
            // By storing the procedure in the environment
            // we've created a circular reference.
            env: env.downgrade(),
        };

        Ok((env, proc))
    }

    /// Set the current scope context for the duration of the given closure.
    fn context<T, F>(&mut self, ctx: Context, block: F) -> Result<T>
    where
        F: FnOnce(&mut Compiler) -> Result<T>,
    {
        let old_context = self.context;
        self.context = ctx;
        let result = block(self);
        self.context = old_context;

        result
    }

    /// Create a new lexical scope, storing the current scoping
    /// depth and replacing it with the given scope.
    ///
    /// Local variables will be declared in the new scope, shadowing
    /// outer ones. Accessing outer variables will create up-values.
    ///
    /// Once the closure returns, the original scope is restored.
    ///
    /// # Returns
    ///
    /// Returns the value returned from the closure, as well as
    /// the newly compiled procedure.
    fn scope<T, F>(&mut self, block: F) -> Result<T>
    where
        F: FnOnce(&mut Compiler) -> Result<T>,
    {
        // TODO: Review whether these sub-proc scopes are needed.
        self.stack_offsets.push(self.stack_offset);
        // self.stack_offset = self.proc.locals.len();
        self.depth += 1;
        let result = block(self);
        self.depth -= 1;
        // self.proc.locals.truncate(self.stack_offset);
        self.stack_offset = self.stack_offsets.pop().unwrap();

        result
    }

    /// Create a new procedure and a lexical scope to encapsulate it.
    fn proc_scope<T, F>(&mut self, block: F) -> Result<(T, ProcState)>
    where
        F: FnOnce(&mut Compiler) -> Result<T>,
    {
        println!("start procedure");
        let prev_proc = mem::replace(&mut self.proc, ProcState::new());
        self.proc_stack.push(prev_proc);
        let result = self.scope(|compiler| Ok(block(compiler)))?;
        let new_proc = mem::replace(&mut self.proc, self.proc_stack.pop().unwrap());
        println!("end procedure");

        result.map(|r| (r, new_proc))
    }

    /// Compile a sequence of expressions.
    ///
    /// The given expression in the `expr` argument must be a list.
    ///
    /// Only the result of the final expression is left
    /// on the operand stack during evaluation.
    fn compile_sequence(&mut self, expr: &Expr) -> Result<()> {
        if !matches!(expr, Expr::Sequence(_)) {
            return Err(Error::Reason("expected a sequence or nil".to_string()));
        }

        let expressions = expr.as_slice().unwrap();
        self.compile_sequence_slice(expressions)
    }

    // FIXME: When expressions are linked-lists this needs to go.
    fn compile_sequence_slice(&mut self, expressions: &[Expr]) -> Result<()> {
        if let Some((last, preceding)) = expressions.split_last() {
            for expr in preceding {
                self.compile_expr(expr)?;

                // Discard the result values of the preceding expressions.
                self.proc.emit_op(Op::Pop);
            }

            self.compile_expr(last)?;
        }

        Ok(())
    }

    /// Compile a single expression.
    ///
    /// Returns the number of resulting values the expression's
    /// evaluation would leave on the operand stack during runtime.
    fn compile_expr(&mut self, expr: &Expr) -> Result<()> {
        println!("compiler::compile_expr({expr:?})");

        match expr {
            // Nil literal
            Expr::Nil => {
                self.proc.emit_op(Op::PushNil);
            }
            // Void literal
            Expr::Void => {
                self.proc.emit_op(Op::PushVoid);
            }
            // Number literal
            Expr::Number(_) => {
                let constant_id = self.add_constant(expr.clone());
                self.proc.emit_op(Op::PushConstant(constant_id));
            }
            // Boolean literal
            Expr::Bool(boolean) => {
                let op = if *boolean {
                    Op::PushTrue
                } else {
                    Op::PushFalse
                };
                self.proc.emit_op(op);
            }
            Expr::Ident(ident) => {
                // Attempt to access a variable by identifier.
                self.compile_access(ident.as_str())?;
            }
            Expr::Quote(value) => {
                self.compile_quote_form(&*value)?;
            }
            Expr::List(list) => {
                self.compile_form(list.as_slice())?;
            }
            Expr::Sequence(_) => {
                self.compile_sequence(expr)?;
            }
            _ => todo!("compile_expr: {expr:?}"),
        }

        Ok(())
    }

    fn compile_end(&mut self) -> Result<()> {
        self.proc.emit_op(Op::Return);
        self.proc.emit_op(Op::End);
        Ok(())
    }

    /// Compile variable access.
    ///
    /// # Return
    ///
    /// Returns the symbol for the location where the variable is stored.
    fn compile_access(&mut self, name: &str) -> Result<()> {
        match self.resolve_variable_mut(name) {
            Some(Variable::Local(local_id)) => {
                self.proc.emit_op(Op::LoadLocalVar(local_id));
                Ok(())
            }
            // Current scope is capturing a local variable in an outer scope's slot.
            //
            // The current closure will have to keep track of captured values on
            // the heap.
            Some(Variable::NonLocal(up_value_id)) => {
                self.proc.emit_op(Op::LoadUpValue(up_value_id));
                Ok(())
            }
            Some(Variable::Global(symbol)) => {
                self.proc.emit_op(Op::LoadEnvVar(symbol));
                Ok(())
            }
            None => Err(error_unbound_variable!(name)),
        }
    }

    fn compile_form(&mut self, list: &[Expr]) -> Result<()> {
        if self.compile_special_form(list)? {
            Ok(())
        } else {
            // The default s-expression form is a procedure call.
            self.compile_call(list)
        }
    }

    /// Attempt to compile a special form.
    ///
    /// Special forms are expression that follow unusual evaluation rules.
    ///
    /// They are implemented as compiler intrinsics that generate inlined bytecode.
    ///
    /// # Return
    ///
    /// Returns `true` if the form is considered a special form.
    /// Returns `false` if the form cannot be identified, with no bytecode emitted.
    fn compile_special_form(&mut self, list: &[Expr]) -> Result<bool> {
        // TODO: When the identifiers themselves are evaluated like variables then a special error must be raised.
        // > define
        // error: fundamental name cannot be used as a variable.

        if let Some((Expr::Ident(operator), rest)) = list.split_first() {
            match operator.as_str() {
                "define" => {
                    self.compile_define_form(rest)?;
                    Ok(true)
                }
                "lambda" => {
                    self.compile_lambda_form(rest)?;
                    Ok(true)
                }
                "let" => {
                    todo!("let form")
                }
                "let*" => {
                    todo!("let* form")
                }
                "letrec" => {
                    todo!("letrec form")
                }
                "fluid-let" => {
                    todo!("fluid-let form")
                }
                "if" => {
                    self.compile_if_form(rest, false)?;
                    Ok(true)
                }
                "cond" => {
                    self.compile_cond_form(rest)?;
                    Ok(true)
                }
                "set!" => {
                    todo!("set! form")
                }
                "quote" => {
                    self.compile_quote_form_slice(rest)?;
                    Ok(true)
                }
                _ => Ok(false),
            }
        } else {
            Ok(false)
        }
    }

    fn compile_call(&mut self, list: &[Expr]) -> Result<()> {
        println!("compiler::compile_call({list:?})");

        if list.is_empty() {
            return Err(Error::Reason("ill-formed expression".to_string()));
        }

        if let Some((operator, rest)) = list.split_first() {
            match operator {
                // Variable can be resolved at compile time.
                Expr::Ident(ident) => {
                    // Lookup procedure using the first atom of the sequence.
                    self.compile_access(ident.as_str())?;
                }
                // Operator is an expression that must first be evaluated.
                expr => {
                    self.compile_expr(expr)?;
                }
            }

            // TODO: Variadic procedures take the rest of their arguments as list. We need to store signature information to accomplish this.
            // TODO: Lists need to be changed ti linked-lists.
            for arg in rest {
                self.compile_expr(arg)?;
            }

            self.proc.emit_op(Op::CallNative {
                arity: rest.len() as u8,
            });

            Ok(())
        } else {
            Err(Error::Reason("call sequence is empty".to_string()))
        }
    }

    /// Compile the `define` special form.
    ///
    /// A fundamental special form that defines a variable in the current environment.
    ///
    /// Definitions can appear in two places, at the top level of a program
    /// where they are called **top-level definitions** or at the beginning
    /// of a body where they are called **internal definitions**. It is an
    /// error to place a define anywhere else.
    ///
    /// Definitions also have a second form that also defines a procedure.
    ///
    /// # Return
    ///
    /// Returns the [`SymbolId`] of the defined variable.
    fn compile_define_form(&mut self, rest: &[Expr]) -> Result<Variable> {
        // TODO: May define create duplicates in top-level but not block level?
        match rest
            .get(0)
            .ok_or_else(|| Error::Reason("identifier or list expected".to_string()))?
        {
            Expr::Ident(var_name) => {
                match self.context {
                    Context::TopLevel => {
                        // Variables can be redefined
                        let symbol = self.env.borrow_mut().intern_var(var_name);

                        // Define body is an expression and not a block, but may be omitted.
                        let body = rest.get(1).unwrap_or(&Expr::Void);

                        // This expression leaves a value on the stack.
                        self.compile_expr(body)?;

                        self.proc.emit_op(Op::StoreEnvVar(symbol));
                        self.proc.emit_op(Op::Pop);

                        // Define evaluates to a #!void value.
                        //
                        // It is the responsibility of the few contexts where define
                        // is allowed to clean this void off the stack.
                        self.proc.emit_op(Op::PushVoid);

                        Ok(Variable::Global(symbol))
                    }
                    Context::BodyStart => {
                        let local_id = self.declare_local(var_name.as_str())?;

                        // Define body is an expression and not a block, but may be omitted.
                        let body = rest.get(1).unwrap_or(&Expr::Void);

                        // This expression leaves a value on the stack.
                        self.compile_expr(body)?;

                        self.proc.emit_op(Op::StoreLocalVar(local_id));
                        self.proc.emit_op(Op::Pop);

                        // INVARIANT: We don't need to leave Void on the stack.
                        //
                        // This define form may only appear in bodies, they are
                        // always part of a sequence that will discard expression
                        // results until the last one.
                        //
                        // Creating a body that ends with a define is an error.
                        //
                        // This form should never appear at the top-level.
                        Ok(Variable::Local(local_id))
                    }
                    Context::BodyRest => {
                        return Err(Error::Reason("ill-formed special form: define must appear at top-level or first in body".to_string()));
                    }
                }
            }
            Expr::List(formals) => {
                // The first formal is the name of the procedure.
                let (_name, _args) = formals
                    .split_first()
                    .ok_or_else(|| Error::Reason("ill-formed special form".to_string()))?;

                // Declare a variable first because the lambda body can
                // recursively call itself using the variable name.

                todo!("define procedure form")
            }
            _ => Err(Error::Reason("ill-formed special form".to_string())),
        }
    }

    /// Compile the `lambda` special form.
    ///
    /// ```scheme
    /// (lambda <formal> <body>)
    /// (lambda (<formals>) <body>)
    /// (lambda (<formals> . <rest>) <body>)
    /// ```
    fn compile_lambda_form(&mut self, rest: &[Expr]) -> Result<()> {
        if let Some((formals, rest)) = rest.split_first() {
            let (_, proc_state) = self.proc_scope(|compiler| {
                match formals {
                    // If the formals are a single identifier, then that
                    // identifier is the "rest" variadic parameter.
                    //
                    // The lambda is completely variadic and all arguments will be
                    // passed as a list bound to this formal.
                    Expr::Ident(_name) => {
                        todo!()
                    }
                    // The formal parameter list is a list of identifiers
                    // to which the call arguments will be bound.
                    //
                    // The lambda's arity is determined by the number of
                    // identifiers in this list.
                    //
                    // The parameters may be followed by a dot(.) keyword, after
                    // which the "rest" parameters will be bound as a list.
                    Expr::List(list) => {
                        compiler.proc.sig.arity = 0;
                        let mut variadic: bool = false;

                        for param in list {
                            match param {
                                Expr::Ident(name) => {
                                    // Declare bindings in this scope so the
                                    // arguments can be referenced by name
                                    // in the lambda body.
                                    compiler.declare_local(name.as_str())?;

                                    if variadic {
                                        break;
                                    } else {
                                        compiler.proc.sig.arity += 1;
                                    }
                                }
                                Expr::Keyword(Keyword::Dot) => {
                                    // When we encounter a dot(.) the succeeding parameter
                                    // is the binding to the variadic list.
                                    variadic = true;
                                }
                                _ => {
                                    return Err(Error::Reason(
                                        "parameter must be an identifier".to_string(),
                                    ))
                                }
                            }
                        }

                        compiler.compile_body(rest)?;
                        compiler.proc.emit_op(Op::Return);

                        Ok(())
                    }
                    _ => Err(Error::Reason("parameter must be an identifier".to_string())),
                }
            })?;

            println!("procedure compiled:");
            for (index, op) in proc_state.code.iter().enumerate() {
                println!("  {index:>6} : {op:?}");
            }

            // Reserve an instruction for creating the closure.
            // The procedure constant is not ready yet.
            let op_index = self.proc.reserve_op(Op::Bail);

            // Emit arguments that instruction the VM how to capture the up-values
            // for the closure.
            for up_value in &proc_state.up_values {
                self.proc.emit_op(Op::CaptureValue(up_value.origin.clone()));
            }

            // Mutable compiler state for the procedure prototype is now discarded.
            let proc = proc_state.into_procedure(self.env.clone());

            // TODO: Store procedure in dedicated environment storage, not constant. In REPL the closure variable can live longer than the constant.
            // The procedure definition is stored as a constant in the outer environment.
            let proc_id = self.env.borrow_mut().add_procedure(proc);
            self.proc.patch_op(op_index, Op::CreateClosure(proc_id));

            Ok(())
        } else {
            Err(Error::Reason(
                "ill-formed special form: lambda expects formal parameters followed by a body"
                    .to_string(),
            ))
        }
    }

    /// Compile the `if` special form.
    ///
    /// First the `<test>` expression is evaluated. If the result is truthy,
    /// then the `<consequent>` expression is evaluated. If the result is
    /// false, then the `<alternate>` expression is evaluated.
    ///
    /// In the form where there is no `<alternate>` expression, and the test
    /// results in false, then the result is `#!void`.
    ///
    /// Of all the Scheme values, only `#f` counts as false in conditional
    /// expressions. All other Scheme values, including `#t`, count as true.
    ///
    /// ```scheme
    /// (if <test> <consequent> <alternate>)
    /// (if <test> <consequent>)
    /// ```
    ///
    /// # Tail Calls
    ///
    /// TODO: Handle proper tail calls for branches.
    fn compile_if_form(&mut self, expressions: &[Expr], is_last: bool) -> Result<()> {
        match expressions.split_first() {
            Some((test_expr, rest)) => {
                // <test>
                self.compile_expr(test_expr)?;

                // The start of the <alternate> bytecode can only be determined
                // when the <consequent> is completely emitted.
                let test_jump_index = self.proc.reserve_op(Op::JumpFalse(JumpAddr::zero()));
                self.proc.emit_op(Op::Pop); // <test> result

                // <consequent>
                let consequent = rest.get(0).ok_or_else(|| error_ill_special_form!("if"))?;
                self.compile_expr(consequent)?;

                // Jump over the <alternate>.
                // TODO: Tail calls for conditionals.
                let end_jump_index = self.proc.reserve_op(Op::Jump(JumpAddr::zero()));

                // <alternate>
                let alternate_addr = self.proc.next_op_addr();
                self.proc
                    .patch_op(test_jump_index, Op::JumpFalse(alternate_addr));
                self.proc.emit_op(Op::Pop); // <test> result

                match rest.get(1) {
                    Some(alternate) => {
                        self.compile_expr(alternate)?;
                    }
                    // When there is no explicit <alternate> then the `if` result is unspecified.
                    //
                    // Implicitly return void.
                    None => {
                        self.proc.emit_op(Op::PushVoid);
                    }
                }

                // The end of the <consequent> block must jump to the end of <alternate>
                // to avoid a true test falling through to the wrong block.
                let alternate_end = self.proc.next_op_addr();
                self.proc.patch_op(end_jump_index, Op::Jump(alternate_end));

                Ok(())
            }
            None => Err(Error::Reason("ill-formed special form".to_string())),
        }
    }

    /// Compile the `cond` special form.
    ///
    /// ```scheme
    /// (cond <clause₁> <clause₂> ...)
    /// (cond <clause₁> <clause₂> ... (else <expression₁> <expression₂> ...))
    /// ```
    ///
    /// `<clause>` takes one of two forms:
    ///
    /// ```scheme
    /// <clause> → (<test> <expression₁> <expression₂> ...)
    /// <clause> → (<test> => <expression>)
    /// ```
    ///
    /// Note that for the `cond` form the `else` clause does not have a `=>` variant.
    fn compile_cond_form(&mut self, clauses: &[Expr]) -> Result<()> {
        println!("compile::compile_cond_form({clauses:?})");

        if clauses.is_empty() {
            return Err(error_ill_special_form!("cond"));
        }

        let mut next: Option<usize> = None;
        let mut ends = vec![];
        let mut is_last = false;

        for clause in clauses {
            if is_last {
                return Err(Error::Reason("else clause must be last".to_string()));
            }

            // The previous clause falls through when it evaluates to false.
            if let Some(op_index) = next.take() {
                let addr = self.proc.next_op_addr();
                self.proc.patch_op(op_index, Op::JumpFalse(addr));

                // Remove the result of the previous test.
                self.proc.emit_op(Op::Pop); // #f
            }

            let sequence = clause
                .as_sequence()
                .ok_or_else(|| error_ill_special_form!("cond"))?;

            match sequence.first() {
                Some(Expr::Ident(ident)) if ident == "else" => {
                    // Ensure else clause is last
                    is_last = true;

                    // Skip over `else`
                    match sequence.get(1..) {
                        Some(expressions) => {
                            self.compile_sequence_slice(expressions)?;
                        }
                        // It's an error for `else` to be empty.
                        None => {
                            return Err(error_ill_special_form!("cond"));
                        }
                    }

                    // Skip over the void return.
                    ends.push(self.proc.reserve_op(Op::Jump(JumpAddr::zero())));
                }
                Some(_) => {
                    let (test, rest) = sequence
                        .split_first()
                        .ok_or_else(|| error_ill_special_form!("cond"))?;

                    // <test>
                    self.compile_expr(test)?;

                    // Jump to the next clause if this <test> fails.
                    next = Some(self.proc.reserve_op(Op::JumpFalse(JumpAddr::zero())));

                    match rest.get(1) {
                        // The `=>` alternate form takes one expression as a procedure,
                        // and calls it with the result of the <test> expression.
                        Some(Expr::Ident(arrow)) if arrow == "=>" => {
                            let callable =
                                rest.get(1).ok_or_else(|| error_ill_special_form!("cond"))?;
                            self.compile_expr(callable)?;

                            // This form only allows for one expression.
                            if !(&rest[2..]).is_empty() {
                                return Err(error_ill_special_form!("cond"));
                            }
                        }
                        // The default form is simply a sequence of expressions.
                        _ => {
                            // Discard the result of <test>
                            self.proc.emit_op(Op::Pop);

                            self.compile_sequence_slice(rest)?;

                            // `cond` evaluation stops with the first clause that is true.
                            //
                            // Prevent the clause from falling through to the next test
                            // by jumping to the end of the `cond` block.
                            ends.push(self.proc.reserve_op(Op::Jump(JumpAddr::zero())));

                            continue;
                        }
                    }
                }
                // <clause> must have at least one expression
                None => {
                    return Err(error_ill_special_form!("cond"));
                }
            }
        }

        // When no clauses evaluated to true, and there is no `else`,
        // then the return value of the `cond` is unspecified.
        //
        // When `cond` ends with `else` there is no `next`,
        // because `else` has no test.
        if let Some(op_index) = next.take() {
            let addr = self.proc.next_op_addr();
            self.proc.patch_op(op_index, Op::JumpFalse(addr));
            self.proc.emit_op(Op::Pop); // #f
            self.proc.emit_op(Op::PushVoid);
        }

        let end_addr = self.proc.next_op_addr();

        for op_index in ends.drain(..) {
            self.proc.patch_op(op_index, Op::Jump(end_addr.clone()));
        }

        assert!(next.is_none());

        Ok(())
    }

    /// Compile the `case` special form.
    ///
    /// ```scheme
    /// (case <key> <clause₁> <clause₂> ...)
    /// ```
    fn compile_case_form(&mut self, rest: &[Expr]) -> Result<()> {
        todo!()
    }

    /// Compile the body of a `define`, `lambda`, `let`, etc...
    fn compile_body(&mut self, rest: &[Expr]) -> Result<()> {
        self.context(Context::BodyStart, |compiler| {
            // Compile the start of a body.
            //
            // This is where definitions are allowed. We keep compiling until a
            // non-definition expression is encountered.
            let mut body_expressions = rest;

            for expr in rest {
                if let Expr::List(list) = expr {
                    if let Some((Expr::Ident(name), def_rest)) = list.split_first() {
                        match name.as_str() {
                            "define" => {
                                compiler.compile_define_form(def_rest)?;
                                body_expressions = &rest[1..];
                            }
                            "define-syntax" => {
                                todo!("define-syntax")
                            }
                            _ => break,
                        }
                    }
                } else {
                    break;
                }
            }

            compiler.context(Context::BodyRest, |compiler| {
                // No further definitions not allowed here.

                match body_expressions.split_last() {
                    Some((last, preceding)) => {
                        for expr in preceding {
                            compiler.compile_expr(expr)?;

                            // Discard the result values of the preceding expressions.
                            compiler.proc.emit_op(Op::Pop);
                        }

                        // Only the last expression's result is left on the stack.
                        compiler.compile_expr(last)?;

                        Ok(())
                    }
                    None => {
                        // INVARIANT: Preventing the define form as the last expression of a body
                        // is an important assumption in `compile_define_form()`.
                        Err(Error::Reason(
                            "body must contain at least one expression".to_string(),
                        ))
                    }
                }
            })?;

            Ok(())
        })
    }

    /// Compile an expression as a constant value.
    fn compile_quote_form_slice(&mut self, expressions: &[Expr]) -> Result<ConstantId> {
        println!("compiler::compile_quote_form_slice({expressions:?})");
        match expressions {
            [value] => self.compile_quote_form(value),
            [..] => Err(error_ill_special_form!("quote")),
        }
    }

    fn compile_quote_form(&mut self, value: &Expr) -> Result<ConstantId> {
        println!("compiler::compile_quote_form({value:?})");
        let constant_id = self.add_constant(value.clone());
        self.proc.emit_op(Op::PushConstant(constant_id));
        Ok(constant_id)
    }

    /// Add a constant value to the current environment.
    ///
    /// Returns the [`ConstantId`] identifying its location.
    ///
    /// Does not emit a load operation.
    fn add_constant(&mut self, value: Expr) -> ConstantId {
        match self.proc.constants.iter().position(|el| el == &value) {
            Some(index) => ConstantId::new(index as u16),
            None => {
                let next_index = self.proc.constants.len();
                self.proc.constants.push(value);
                ConstantId::new(next_index as u16)
            }
        }
    }

    /// Add a local variable to the current procedure.
    ///
    /// Local variables defined in a scope will shadow variables
    /// with the same name defined in outer scopes.
    ///
    /// # Errors
    ///
    /// Returns an error if the current scope is the top-level.
    /// Locals are only for bodies.
    ///
    /// Returns an error if a local with the given name already exists
    /// in the current scope.
    ///
    /// # Returns
    ///
    /// A new [`LocalId`] identifying the local variable's location,
    /// relative to the start of the call frame during runtime.
    fn declare_local(&mut self, name: &str) -> Result<LocalId> {
        // Resolve local by scanning the lexical stack backwards.
        for local in self.proc.locals.iter().rev() {
            if local.depth != self.depth {
                // We've left our scope and stop the scan.
                // Any locals with the same name will now be shadowed.
                break;
            }

            if name == local.name {
                return Err(Error::Reason(format!(
                    "duplicate definition of local variable \"{name}\""
                )));
            }
        }

        let index = self.proc.locals.len() - self.stack_offset;

        if index >= MAX_LOCALS {
            return Err(Error::Reason(format!(
                "number of local variables in scope exceeds maximum of {MAX_LOCALS}"
            )));
        }

        let local_id = LocalId::new(index as u8);
        println!("declare local {local_id:?}:{name:?}");

        let stack_offset = StackPos::new(self.proc.locals.len());
        self.proc.locals.push(Local {
            id: local_id,
            stack_offset,
            name: SmolStr::from(name),
            depth: self.depth,
            is_captured: false,
        });
        Ok(local_id)
    }

    /// Scan the lexical scopes for a variable with the given name.
    ///
    /// # Side-effects
    ///
    /// If the scan leaves the local procedure boundary, and finds
    /// the variable in an outer scope, that variable must be marked
    /// as captured.
    fn resolve_variable_mut(&mut self, name: &str) -> Option<Variable> {
        println!("compiler::resolve_variable_mut({name:?})");

        if let Some(variable) = resolve_non_env_mut(&mut self.proc, &mut self.proc_stack, name) {
            return Some(variable);
        }

        println!("compiler::resolve_variable_mut(...), resolving env var");
        // If the variable cannot be found in the locals of the lexical scopes,
        // then we fall back onto the enclosing environment.
        self.env
            .borrow()
            .resolve_var(name)
            .map(|symbol| Variable::Global(symbol))
    }
}

/// Resolve either a local variable or an up-value.
fn resolve_non_env_mut(
    proc: &mut ProcState,
    stack: &mut [ProcState],
    name: &str,
) -> Option<Variable> {
    println!("compiler::resolve_non_env_mut({proc:?}, {stack:?}, {name:?})");

    // First attempt to resolve the variable in a local scope,
    // then in an outer scope, then the enclosing environment.
    if let Some(local) = resolve_local(proc, name) {
        return Some(Variable::Local(local.id.clone()));
    }

    // If a local variable can't be found, we scan the parent scope
    // for a local variable we could use as an up-value.
    if let Some(up_value) = find_up_value_mut(proc, stack, name) {
        return Some(Variable::NonLocal(up_value.clone()));
    }

    None
}

/// Resolve a local variable in the current procedure, without scanning for up-values.
fn resolve_local<'a>(proc: &'a mut ProcState, name: &str) -> Option<&'a Local> {
    println!("compiler::resolve_local({proc:?}, {name:?})");

    for local in proc.locals.iter().rev() {
        if name == local.name {
            return Some(local);
        }
    }

    None
}

fn find_up_value_mut(
    proc: &mut ProcState,
    stack: &mut [ProcState],
    name: &str,
) -> Option<UpValueId> {
    println!("compiler::find_up_value_mut({proc:?}, {stack:?}, {name:?})");

    for up_value in &proc.up_values {
        if name == up_value.name {
            // The up-value has previously been captured.
            return Some(up_value.id);
        }
    }

    // No existing up-value has been captured.
    //
    // Scan the procedure stack in reverse looking at their local variables
    // and up-values.
    if let Some((parent, rest)) = stack.split_last_mut() {
        println!("compiler::find_up_value_mut(...), parent -> {parent:?}");

        match resolve_non_env_mut(parent, rest, name) {
            // A local variable was found in the parent scope.
            Some(Variable::Local(local_id)) => {
                println!("compiler::find_up_value_mut(...), local -> {local_id:?}");
                Some(proc.insert_up_value(name, UpValueOrigin::Parent(local_id)))
            }
            // An up-value has been found in a higher scope beyond the parent scope.
            Some(Variable::NonLocal(up_value_id)) => {
                println!("compiler::find_up_value_mut(...), non-local -> {up_value_id:?}");
                // Flatten the closure by copying the up-value into this one.
                Some(proc.insert_up_value(name, UpValueOrigin::Outer(up_value_id)))
            }
            Some(Variable::Global(_)) => {
                unreachable!("global variables cannot be up-values")
            }
            None => None,
        }
    } else {
        println!("compiler::find_up_value_mut(...), no parent");

        None
    }
}

/// Mutable bookkeeping for compiling a procedure prototype.
#[derive(Debug)]
struct ProcState {
    /// Generated result bytecode.
    code: Vec<Op>,
    sig: Signature,
    locals: Vec<Local>,
    constants: Vec<Expr>,
    /// List of variables in an outer scope.
    up_values: Vec<UpValueInfo>,
}

impl ProcState {
    fn new() -> Self {
        Self {
            code: Vec::new(),
            sig: Signature::empty(),
            locals: Vec::new(),
            constants: Vec::new(),
            up_values: Vec::new(),
        }
    }

    fn next_op_addr(&self) -> JumpAddr {
        let next_index = self.code.len();
        JumpAddr::new(next_index)
    }

    fn emit_op(&mut self, op: Op) {
        self.code.push(op)
    }

    /// Emit the given instruction, and return its index in the bytecode buffer.
    ///
    /// This index can later be used to patch the instruction.
    fn reserve_op(&mut self, op: Op) -> usize {
        let index = self.code.len();
        self.code.push(op);
        index
    }

    /// Patch the contents of a previously emitted instruction.
    fn patch_op(&mut self, index: usize, op: Op) {
        self.code[index] = op;
    }

    fn into_procedure(self, env: Handle<Env>) -> Proc {
        println!("compiled procedure: {self:?}");

        let Self {
            code,
            sig,
            locals,
            constants,
            up_values,
            ..
        } = self;

        Proc {
            code: code.into_boxed_slice(),
            sig,
            constants: constants.into_boxed_slice(),
            local_count: locals.len(),
            up_value_count: up_values.len(),
            env: env.downgrade(),
        }
    }

    fn push_up_value(&mut self, up_value: UpValueInfo) -> UpValueId {
        let index = self.up_values.len();
        let id = UpValueId::new(index as u8);
        self.up_values.push(UpValueInfo { id, ..up_value });
        id
    }

    /// Insert up-value without checking if it already exists.
    fn insert_up_value(&mut self, name: &str, origin: UpValueOrigin) -> UpValueId {
        let index = self.up_values.len();
        let id = UpValueId::new(index as u8);
        self.up_values.push(UpValueInfo {
            id,
            name: SmolStr::new(name),
            stack_pos: StackPos(0),
            origin,
        });
        id
    }

    fn intern_up_value(&mut self) -> UpValueInfo {
        todo!()
    }

    fn scope(&mut self) {
        todo!()
    }
}

#[derive(Debug)]
enum Variable {
    Local(LocalId),
    NonLocal(UpValueId),
    /// The symbol identifying the location where the variable is stored int he current environment.
    Global(SymbolId),
}

declare_id!(
    /// The absolute stack index where a local variable is located, regardless of scope.
    ///
    /// This points into the stack of locals for the *lexical scopes* and is only valid
    /// for compile time.
    ///
    /// During runtime the evaluation stack may have more frames, and temporaries, taking
    /// up stack space.
    /// TODO: This is confusing with `stack_offset` for start of frame. Rename to `StackPos`?
    struct StackPos(usize)
);

/// Slot for a local variable on the lexical stack.
#[derive(Debug, Clone)]
struct Local {
    /// The Id describes the location for where the local variable is stored.
    ///
    /// It is relative to the start of a scope's runtime stack frame.
    ///
    /// It must thus be valid fro both compile time (lexical scope) and runtime (evaluation stack).
    id: LocalId,
    stack_offset: StackPos,
    name: SmolStr,
    /// The depth of the scope where the variable was declared.
    depth: usize,
    /// Flag indicating that the variable has been captured by an inner scope.
    is_captured: bool,
}

#[derive(Debug, Clone)]
struct UpValueInfo {
    /// The Id describes the location of the up-value in the heap buffer
    /// of the closure that will result from compiling a procedure.
    id: UpValueId,
    name: SmolStr,
    /// Index into lexical stack where the local variable is located.
    stack_pos: StackPos,
    /// Indicates where the up-value originated from, relative to the
    /// current local scope.
    origin: UpValueOrigin,
}

/// The context categorises a scope, or part of a scope, for implementing
/// special semantic rules within expressions.
///
/// Certain special forms are only allowed in certain places.
///
/// Traditionally these rules would be enforced by the "evaluator", but
/// because we're compiling to bytecode, the compiler must enforce
/// semantic correctness.
///
/// # Examples
///
/// The `define` special form may only appear at the top-level of a program,
/// or at the start of a body.
///
/// ```scheme
/// (define x 42)    ;; yes
/// (lambda (y z)
///   (define x 42)  ;; yes
///   (+ x y z)
///   )
/// ```
///
/// If the `define` appears anywhere else, an error is raised.
///
/// ```scheme
/// (lambda (a b)
///   (+ a b)
///   (define x 42)  ;; NO!!
///   )
///
/// (+ 1 2 3 (define x 42))  ;; NO!!
/// ```
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum Context {
    /// The top level sequence of s-expressions of a program.
    ///
    /// Here global variables can be defined and redefined.
    TopLevel,
    /// The start of a body block, for `lambda`, `let`, etc...
    ///
    /// Here local variables can be fined, but not redefined.
    BodyStart,
    /// The tail of the body block.
    ///
    /// No further definitions are allowed.
    BodyRest,
}

impl Context {
    fn is_top_level(&self) -> bool {
        matches!(self, Self::TopLevel)
    }

    fn is_body_start(&self) -> bool {
        matches!(self, Self::BodyStart)
    }

    fn is_body_rest(&self) -> bool {
        matches!(self, Self::BodyRest)
    }
}
